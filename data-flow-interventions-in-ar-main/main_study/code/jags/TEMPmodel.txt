 # open quote for setting model specs as a string
  model{
    # individual yi values come from a t distribution centered at a baseline a0 plus a deflection a[x[i]] for the group, with standard deviation ySigma, and a nu normalization parameter:
    for(i in 1:Ntotal){
        y[i] ~ dt(a0 + a[x[i]], 1/ySigma[x[i]]^2, nu) # nested index of group: x[i] = j, when score comes from jth group
    }
    
    # transformed parameter nu
    nu <- nuMinusOne+1 
    nuMinusOne ~ dexp(1/29) 
    
    # specify priors on sigmas and baseline
    for(j in 1:NxLvl){ # NxLvl = number of groups
      ySigma[j] ~ dgamma(ySigmaSh, ySigmaRa) # sigma within-group
    }
    ySigmaSh <- 1 + ySigmaMode * ySigmaRa # shape
    ySigmaRa <- ((ySigmaMode + sqrt(ySigmaMode^2 + 4*ySigmaSD^2)) / (2*ySigmaSD^2)) # rate
    ySigmaMode ~ dgamma(aGammaShRa[1], aGammaShRa[2]) # omega
    ySigmaSD ~ dgamma(aGammaShRa[1], aGammaShRa[2]) # sigma_sigma
    a0 ~ dnorm(yMean, 1 / (ySD*10)^2) # beta_0 = a0 unconstrained baseline: centered on the data mean and made very wide relative to the variance of the data
    for(j in 1:NxLvl){
      a[j] ~ dnorm(0.0, 1/aSigma^2) # beta_j = a[j] unconstrained deflection of groups
    } 
    aSigma ~ dgamma(aGammaShRa[1], aGammaShRa[2]) # sigma between-group = sigma_beta = aSigma (SD of deflections): nonzero mode = shape and rate parameters of the gamma distribution are set to its mode (sd(y)/2) and SD (2*sd(y)) using the function gammaShRaFromModeSD() and stored in vector 'aGammaShRa'
    
    # Convert a0,a[] to sum-to-zero b0,b[]:
    for(j in 1:NxLvl){ 
      m[j] <- a0 + a[j] # mu: predicted group means
    }
    b0 <- mean(m[1:NxLvl]) # beta0: new baseline as mean of group means
    for(j in 1:NxLvl){
      b[j] <- m[j] - b0 # beta_j: sum-to-zero deflections
    }
  }
  
